name: "Terraform Deploy GKE"

on:
  push:
    branches:
      - main
    paths:
      # Trigger apenas quando arquivos Terraform s칚o alterados
      - '**/*.tf'
      - '**/*.tfvars'
      - '.github/workflows/terraform-deploy.yaml'
  pull_request:
    branches:
      - main
    paths:
      - '**/*.tf'
      - '**/*.tfvars'
      - '.github/workflows/terraform-deploy.yaml'
  workflow_dispatch:  # Permite execu칞칚o manual
    inputs:
      operation:
        description: "Selecione a opera칞칚o manual"
        required: true
        default: "deploy"
        type: choice
        options:
          - deploy
          - destroy

permissions:
  contents: read
  id-token: write
  pull-requests: write

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      vpc: ${{ steps.filter.outputs.vpc }}
      gke: ${{ steps.filter.outputs.gke }}
      mesh: ${{ steps.filter.outputs.mesh }}
      project: ${{ steps.filter.outputs.project }}
      root: ${{ steps.filter.outputs.root }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Necess치rio para comparar com commit anterior

      - name: Detect changes
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            vpc:
              - 'modules/vpc/**'
              - 'main.tf'
              - 'variables.tf'
            gke:
              - 'modules/gke/**'
              - 'main.tf'
              - 'variables.tf'
            mesh:
              - 'modules/anthos-service-mesh/**'
              - 'main.tf'
            project:
              - 'main.tf'
              - 'variables.tf'
            root:
              - 'main.tf'
              - 'variables.tf'
              - 'outputs.tf'
              - 'versions.tf'

  terraform-plan:
    needs: detect-changes
    runs-on: ubuntu-latest
    if: >
      (
        github.event_name == 'workflow_dispatch' &&
        github.event.inputs.operation == 'deploy'
      ) ||
      (
        github.event_name == 'pull_request'
      ) ||
      (
        github.event_name != 'workflow_dispatch' &&
        (
          needs.detect-changes.outputs.vpc == 'true' ||
          needs.detect-changes.outputs.gke == 'true' ||
          needs.detect-changes.outputs.mesh == 'true' ||
          needs.detect-changes.outputs.project == 'true' ||
          needs.detect-changes.outputs.root == 'true'
        )
      )

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud via OIDC
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: "projects/961330940767/locations/global/workloadIdentityPools/github-actions-pool/providers/github"
          service_account: "terraform-deployer@infra-474223.iam.gserviceaccount.com"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        run: terraform init

      - name: Terraform Format Check
        run: terraform fmt -check

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        id: plan
        run: |
          set -o pipefail
          set +e
          mkdir -p logs
          terraform plan -no-color -out=tfplan | tee logs/terraform-plan.log
          PLAN_EXIT=${PIPESTATUS[0]}
          set -e
          echo "exitcode=$PLAN_EXIT" >> "$GITHUB_OUTPUT"
          if [ "$PLAN_EXIT" -eq 1 ]; then
            echo "Terraform plan falhou." >&2
            exit 1
          fi
          terraform show -no-color tfplan > tfplan.txt

      - name: Comment PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          PLAN_FILE: tfplan.txt
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let plan = '';
            try {
              plan = fs.readFileSync(process.env.PLAN_FILE, 'utf8');
            } catch (error) {
              plan = 'Falha ao ler o plano Terraform.';
            }
            const body = [
              '#### Terraform Plan 游닀',
              '```',
              plan,
              '```',
              `*Pusher: @${context.actor}, Action: \`${context.eventName}\`*`
            ].join('\n');
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

      - name: Diagnosticar falhas conhecidas (plan)
        if: failure()
        run: |
          if compgen -G "logs/*.log" > /dev/null; then
            if grep -qi 'namespaces "istio-system" already exists' logs/*.log; then
              cat <<'EOT'
              Foi detectado que o namespace "istio-system" j치 existe no cluster e n칚o est치 sendo gerenciado pelo Terraform.
              Op칞칫es recomendadas:
              1. Importe o namespace existente para o estado com o endere칞o do m칩dulo correspondente (ex.: module.cluster1_addons.kubernetes_manifest.istio_system).
              2. Ajuste/limpe o namespace manualmente com kubectl antes de nova execu칞칚o.
              EOT
            fi
          else
            echo "Nenhum log gerado para an치lise."
          fi
      - name: Publicar logs do Terraform (plan)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-logs-plan
          path: logs
          if-no-files-found: ignore

  terraform-apply:
    needs: [detect-changes, terraform-plan]
    runs-on: ubuntu-latest
    if: >
      (
        github.event_name == 'push' &&
        github.ref == 'refs/heads/main' &&
        (
          needs.detect-changes.outputs.vpc == 'true' ||
          needs.detect-changes.outputs.gke == 'true' ||
          needs.detect-changes.outputs.mesh == 'true' ||
          needs.detect-changes.outputs.project == 'true' ||
          needs.detect-changes.outputs.root == 'true'
        )
      ) ||
      (
        github.event_name == 'workflow_dispatch' &&
        github.event.inputs.operation == 'deploy' &&
        github.ref == 'refs/heads/main'
      )

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud via OIDC
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: "projects/961330940767/locations/global/workloadIdentityPools/github-actions-pool/providers/github"
          service_account: "terraform-deployer@infra-474223.iam.gserviceaccount.com"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        run: |
          set -o pipefail
          set +e
          mkdir -p logs
          terraform plan -no-color -out=tfplan | tee logs/terraform-plan-apply.log
          PLAN_EXIT=${PIPESTATUS[0]}
          set -e
          if [ "$PLAN_EXIT" -eq 1 ]; then
            echo "Terraform plan falhou." >&2
            exit 1
          fi

      - name: Terraform Apply
        run: |
          set -o pipefail
          set +e
          export TF_LOG=ERROR
          terraform apply -auto-approve tfplan | tee logs/terraform-apply.log
          APPLY_EXIT=${PIPESTATUS[0]}
          set -e
          if [ "$APPLY_EXIT" -ne 0 ]; then
            echo "Terraform apply falhou." >&2
            exit "$APPLY_EXIT"
          fi

      # Opcional: Aplicar apenas recursos espec칤ficos baseado em mudan칞as
      # Descomente e ajuste conforme necess치rio
      # - name: Terraform Apply (Targeted - VPC only)
      #   if: needs.detect-changes.outputs.vpc == 'true' && needs.detect-changes.outputs.gke != 'true' && needs.detect-changes.outputs.mesh != 'true'
      #   run: terraform apply -auto-approve -target=module.vpc

      # - name: Terraform Apply (Targeted - GKE only)
      #   if: needs.detect-changes.outputs.gke == 'true' && needs.detect-changes.outputs.vpc != 'true' && needs.detect-changes.outputs.mesh != 'true'
      #   run: terraform apply -auto-approve -target=module.gke_clusters

      - name: Diagnosticar falhas conhecidas (apply)
        if: failure()
        run: |
          if compgen -G "logs/*.log" > /dev/null; then
            if grep -qi 'namespaces "istio-system" already exists' logs/*.log; then
              cat <<'EOT'
              Foi detectado que o namespace "istio-system" j치 existe no cluster e n칚o est치 sendo gerenciado pelo Terraform.
              Importe o recurso para o estado ou limpe-o manualmente antes de tentar novamente.
              EOT
            fi
          else
            echo "Nenhum log gerado para an치lise."
          fi
      - name: Publicar logs do Terraform (apply)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-logs-apply
          path: logs
          if-no-files-found: ignore

  terraform-destroy:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.operation == 'destroy'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud via OIDC
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: "projects/961330940767/locations/global/workloadIdentityPools/github-actions-pool/providers/github"
          service_account: "terraform-deployer@infra-474223.iam.gserviceaccount.com"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan Destroy
        run: |
          set -o pipefail
          set +e
          mkdir -p logs
          terraform plan -destroy -no-color | tee logs/terraform-destroy-plan.log
          PLAN_EXIT=${PIPESTATUS[0]}
          set -e
          if [ "$PLAN_EXIT" -eq 1 ]; then
            echo "Terraform plan destroy falhou." >&2
            exit 1
          fi

      - name: Terraform Destroy
        run: |
          set -o pipefail
          set +e
          terraform destroy -auto-approve | tee logs/terraform-destroy.log
          DESTROY_EXIT=${PIPESTATUS[0]}
          set -e
          if [ "$DESTROY_EXIT" -ne 0 ]; then
            echo "Terraform destroy falhou." >&2
            exit "$DESTROY_EXIT"
          fi

      - name: Diagnosticar falhas conhecidas (destroy)
        if: failure()
        run: |
          if compgen -G "logs/*.log" > /dev/null; then
            if grep -qi 'namespaces "istio-system" already exists' logs/*.log; then
              cat <<'EOT'
              Foi detectado que o namespace "istio-system" j치 existe no cluster e n칚o est치 sendo gerenciado pelo Terraform.
              Importe ou remova o recurso manualmente antes de destruir novamente.
              EOT
            fi
          else
            echo "Nenhum log gerado para an치lise."
          fi

      - name: Publicar logs do Terraform (destroy)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-logs-destroy
          path: logs
          if-no-files-found: ignore

